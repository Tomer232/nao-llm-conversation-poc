import os
import subprocess
import json
from flask import Flask, jsonify, request
from flask_cors import CORS

app = Flask(__name__)
CORS(app)

# Base project directory
BASE_DIR = r"C:\Users\tomer\Desktop\NAO_LLM"
CONTROL_FILE = os.path.join(BASE_DIR, "control_flags.txt")
LOG_FILE = os.path.join(BASE_DIR, "conversation_log.jsonl")
SETTINGS_FILE = os.path.join(BASE_DIR, "settings.json")
ROBOT_STATE_FILE = os.path.join(BASE_DIR, "robot_state.txt")  # same as nao_talk.py

# Explicit venv Python path
PYTHON_EXE = os.path.join(BASE_DIR, "venv", "Scripts", "python.exe")

# Track the conversation process
conversation_proc = None

# Simple status cache for API responses
system_state = {
    "status": "idle"  # "idle" | "running" | "paused" | "ended"
}

# Default settings (must match conversation_loop.py)
DEFAULT_SETTINGS = {
    "question_difficulty": "hard",          # "easy" | "medium" | "hard"
    "interruption_mode": "random",          # "random" | "fixed"
    "fixed_interval_seconds": 30,           # Used when interruption_mode == "fixed"
    "max_interruptions_per_minute": 3,      # Hard interruptions per 60 sec

    "audience_attitude": "neutral",         # "supportive" | "neutral" | "skeptical" | "hostile"
    "max_aggressiveness": "medium",         # "low" | "medium" | "high"

    "total_session_minutes": 0,             # 0 = unlimited
    "warmup_seconds": 0,                    # No hard interruptions during this period
    "max_speaking_seconds": 15,             # Per turn, passed to ASR

    # NEW: TTS voice for OpenAI TTS
    # Allowed: "alloy", "verse", "onyx", "copper", "opal", "amber"
    "tts_voice": "onyx",
}


# ---------------------------------------------------------
# Helpers: settings, control flags, process status, log, robot state
# ---------------------------------------------------------
def load_settings():
    settings = DEFAULT_SETTINGS.copy()
    try:
        with open(SETTINGS_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
            if isinstance(data, dict):
                settings.update(data)
    except Exception:
        pass
    return settings


def save_settings(settings):
    try:
        with open(SETTINGS_FILE, "w", encoding="utf-8") as f:
            json.dump(settings, f, ensure_ascii=False, indent=2)
    except IOError as e:
        print(f"[CONTROL] Failed to save settings: {e}")


def validate_and_merge_settings(payload):
    """Validate incoming settings and merge into current settings."""
    s = load_settings()

    # question_difficulty
    qd = payload.get("question_difficulty")
    if qd in ("easy", "medium", "hard"):
        s["question_difficulty"] = qd

    # interruption_mode
    im = payload.get("interruption_mode")
    if im in ("random", "fixed"):
        s["interruption_mode"] = im

    # fixed_interval_seconds
    try:
        fis = int(payload.get("fixed_interval_seconds", s["fixed_interval_seconds"]))
        fis = max(5, min(fis, 600))
        s["fixed_interval_seconds"] = fis
    except Exception:
        pass

    # max_interruptions_per_minute
    try:
        mipm = int(payload.get("max_interruptions_per_minute", s["max_interruptions_per_minute"]))
        mipm = max(0, min(mipm, 60))
        s["max_interruptions_per_minute"] = mipm
    except Exception:
        pass

    # audience_attitude
    aa = payload.get("audience_attitude")
    if aa in ("supportive", "neutral", "skeptical", "hostile"):
        s["audience_attitude"] = aa

    # max_aggressiveness
    ma = payload.get("max_aggressiveness")
    if ma in ("low", "medium", "high"):
        s["max_aggressiveness"] = ma

    # total_session_minutes
    try:
        tsm = int(payload.get("total_session_minutes", s["total_session_minutes"]))
        tsm = max(0, min(tsm, 240))  # up to 4 hours
        s["total_session_minutes"] = tsm
    except Exception:
        pass

    # warmup_seconds
    try:
        wus = int(payload.get("warmup_seconds", s["warmup_seconds"]))
        wus = max(0, min(wus, 600))  # up to 10 minutes
        s["warmup_seconds"] = wus
    except Exception:
        pass

    # max_speaking_seconds
    try:
        mss = int(payload.get("max_speaking_seconds", s["max_speaking_seconds"]))
        mss = max(5, min(mss, 120))
        s["max_speaking_seconds"] = mss
    except Exception:
        pass

    # NEW: tts_voice
    tv = payload.get("tts_voice")
    if tv in ("alloy", "verse", "onyx", "copper", "opal", "amber"):
        s["tts_voice"] = tv

    return s


def write_control_flag(value: str):
    try:
        with open(CONTROL_FILE, "w", encoding="utf-8") as f:
            f.write(value.strip())
    except IOError as e:
        print(f"[CONTROL] Failed to write control flag: {e}")


def read_control_flag() -> str:
    try:
        with open(CONTROL_FILE, "r", encoding="utf-8") as f:
            return f.read().strip() or "running"
    except IOError:
        return "running"


def read_robot_state() -> str:
    """
    Read the current robot state from robot_state.txt.
    States: "idle", "listening", "thinking", "speaking"
    Default: "idle" on error.
    """
    try:
        with open(ROBOT_STATE_FILE, "r", encoding="utf-8") as f:
            val = f.read().strip().lower()
            return val or "idle"
    except IOError:
        return "idle"


def refresh_status_from_process():
    global conversation_proc, system_state

    if conversation_proc is not None:
        ret = conversation_proc.poll()
        if ret is not None:
            conversation_proc = None
            system_state["status"] = "ended"
            return

    if conversation_proc is not None:
        flag = read_control_flag()
        if flag == "paused":
            system_state["status"] = "paused"
        elif flag == "running":
            system_state["status"] = "running"
        elif flag == "end":
            system_state["status"] = "ended"
        return

    if system_state["status"] not in ("idle", "ended"):
        system_state["status"] = "idle"


# ---------------------------------------------------------
# API endpoints
# ---------------------------------------------------------
@app.route("/status", methods=["GET"])
def get_status():
    refresh_status_from_process()
    resp = dict(system_state)
    resp["robot_state"] = read_robot_state()
    return jsonify(resp)


@app.route("/settings", methods=["GET", "POST"])
def settings_endpoint():
    if request.method == "GET":
        s = load_settings()
        return jsonify(s)

    # POST
    try:
        payload = request.get_json(force=True, silent=True) or {}
    except Exception:
        payload = {}

    s = validate_and_merge_settings(payload)
    save_settings(s)
    return jsonify(s)


@app.route("/start", methods=["POST"])
def start_conversation():
    global conversation_proc, system_state

    refresh_status_from_process()

    if conversation_proc is not None and conversation_proc.poll() is None:
        return jsonify({"error": "Conversation already running", "status": system_state["status"]}), 400

    # Safety: check python exe and script exist
    conv_script = os.path.join(BASE_DIR, "conversation_loop.py")
    if not os.path.exists(PYTHON_EXE):
        print(f"[CONTROL] ERROR: Python executable not found at {PYTHON_EXE}")
        return jsonify({"error": "Python executable not found", "status": system_state["status"]}), 500
    if not os.path.exists(conv_script):
        print(f"[CONTROL] ERROR: conversation_loop.py not found at {conv_script}")
        return jsonify({"error": "conversation_loop.py not found", "status": system_state["status"]}), 500

    # Reset control flag and clear log for a fresh session
    write_control_flag("running")
    try:
        with open(LOG_FILE, "w", encoding="utf-8") as f:
            f.write("")  # truncate
    except IOError as e:
        print(f"[CONTROL] Failed to clear log file: {e}")

    print("[CONTROL] Starting conversation_loop.py...")
    print(f"[CONTROL] Using interpreter: {PYTHON_EXE}")
    try:
        conversation_proc = subprocess.Popen(
            [PYTHON_EXE, "conversation_loop.py"],
            cwd=BASE_DIR,
            stdout=None,
            stderr=None,
            shell=False,
        )
    except Exception as e:
        print(f"[CONTROL] Failed to start conversation_loop.py: {e}")
        return jsonify({"error": str(e), "status": system_state["status"]}), 500

    system_state["status"] = "running"
    return jsonify(system_state)


@app.route("/pause", methods=["POST"])
def pause_conversation():
    global system_state

    refresh_status_from_process()

    if system_state["status"] != "running":
        return jsonify({"error": "Can only pause when running", "status": system_state["status"]}), 400

    write_control_flag("paused")
    system_state["status"] = "paused"
    print("[CONTROL] Pause requested")
    return jsonify(system_state)


@app.route("/resume", methods=["POST"])
def resume_conversation():
    global system_state

    refresh_status_from_process()

    if system_state["status"] != "paused":
        return jsonify({"error": "Can only resume when paused", "status": system_state["status"]}), 400

    write_control_flag("running")
    system_state["status"] = "running"
    print("[CONTROL] Resume requested")
    return jsonify(system_state)


@app.route("/end", methods=["POST"])
def end_conversation():
    global conversation_proc, system_state

    refresh_status_from_process()

    write_control_flag("end")
    system_state["status"] = "ended"
    print("[CONTROL] End requested")

    return jsonify(system_state)


@app.route("/log", methods=["GET"])
def get_log():
    messages = []
    if os.path.exists(LOG_FILE):
        try:
            with open(LOG_FILE, "r", encoding="utf-8") as f:
                for line in f:
                    line = line.strip()
                    if not line:
                        continue
                    try:
                        entry = json.loads(line)
                        messages.append(entry)
                    except json.JSONDecodeError:
                        continue
        except IOError as e:
            print(f"[CONTROL] Failed to read log file: {e}")

    max_messages = 200
    if len(messages) > max_messages:
        messages = messages[-max_messages:]

    return jsonify(messages)


if __name__ == "__main__":
    os.chdir(BASE_DIR)
    print(f"[CONTROL] BASE_DIR = {BASE_DIR}")
    print(f"[CONTROL] PYTHON_EXE = {PYTHON_EXE}")
    app.run(host="127.0.0.1", port=5000, debug=False)
